/*
 * This code was generated by
 *  ___ ___   _   ___ _  _    _____ _   _    _  ___   ___      _   ___ ___      ___   _   ___     ___ ___ _  _ ___ ___    _ _____ ___  ___ 
 * | _ \ __| /_\ / __| || |__|_   _/_\ | |  | |/ | \ / / |    /_\ | _ ) __|___ / _ \ /_\ |_ _|__ / __| __| \| | __| _ \  /_\_   _/ _ \| _ \
 * |   / _| / _ \ (__| __ |___|| |/ _ \| |__| ' < \ V /| |__ / _ \| _ \__ \___| (_) / _ \ | |___| (_ | _|| .` | _||   / / _ \| || (_) |   /
 * |_|_\___/_/ \_\___|_||_|    |_/_/ \_\____|_|\_\ |_| |____/_/ \_\___/___/    \___/_/ \_\___|   \___|___|_|\_|___|_|_\/_/ \_\_| \___/|_|_\
 * 
 * Reach Authentix API
 *  Reach Authentix API helps you easily integrate user authentification in your application. The authentification allows to verify that a user is indeed at the origin of a request from your application.  At the moment, the Reach Authentix API supports the following channels:    * SMS      * Email   We are continuously working to add additionnal channels. ## Base URL All endpoints described in this documentation are relative to the following base URL: ``` https://api.reach.talkylabs.com/rest/authentix/v1/ ```  The API is provided over HTTPS protocol to ensure data privacy.  ## API Authentication Requests made to the API must be authenticated. You need to provide the `ApiUser` and `ApiKey` associated with your applet. This information could be found in the settings of the applet. ```curl curl -X GET [BASE_URL]/configurations -H \"ApiUser:[Your_Api_User]\" -H \"ApiKey:[Your_Api_Key]\" ``` ## Reach Authentix API Workflow Three steps are needed in order to authenticate a given user using the Reach Authentix API. ### Step 1: Create an Authentix configuration A configuration is a set of settings used to define and send an authentication code to a user. This includes, for example: ```   - the length of the authentication code,    - the message template,    - and so on... ``` A configuaration could be created via the web application or directly using the Reach Authentix API. This step does not need to be performed every time one wants to use the Reach Authentix API. Indeed, once created, a configuartion could be used to authenticate several users in the future.    ### Step 2: Send an authentication code A configuration is used to send an authentication code via a selected channel to a user. For now, the supported channels are `sms`, and `email`. We are working hard to support additional channels. Newly created authentications will have a status of `awaiting`. ### Step 3: Verify the authentication code This step allows to verify that the code submitted by the user matched the one sent previously. If, there is a match, then the status of the authentication changes from `awaiting` to `passed`. Otherwise, the status remains `awaiting` until either it is verified or it expires. In the latter case, the status becomes `expired`. 
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.talkylabs.reach.rest.api.authentix;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.JsonParseException;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.talkylabs.reach.base.Resource;
import com.talkylabs.reach.converter.DateConverter;
import com.talkylabs.reach.exception.ApiConnectionException;

import com.talkylabs.reach.exception.ApiException;

import lombok.ToString;

import java.io.IOException;
import java.io.InputStream;
import java.time.ZonedDateTime;

import java.util.Objects;



@JsonIgnoreProperties(ignoreUnknown = true)
@ToString
public class ConfigurationItem extends Resource {
    private static final long serialVersionUID = 157178525838560L;

    public static ConfigurationItemCreator creator(final String serviceName){
        return new ConfigurationItemCreator(serviceName);
    }

    public static ConfigurationItemDeleter deleter(final String pathConfigurationId){
        return new ConfigurationItemDeleter(pathConfigurationId);
    }

    public static ConfigurationItemFetcher fetcher(final String pathConfigurationId){
        return new ConfigurationItemFetcher(pathConfigurationId);
    }

    public static ConfigurationItemReader reader(){
        return new ConfigurationItemReader();
    }

    public static ConfigurationItemUpdater updater(final String pathConfigurationId){
        return new ConfigurationItemUpdater(pathConfigurationId);
    }

    /**
    * Converts a JSON String into a ConfigurationItem object using the provided ObjectMapper.
    *
    * @param json Raw JSON String
    * @param objectMapper Jackson ObjectMapper
    * @return ConfigurationItem object represented by the provided JSON
    */
    public static ConfigurationItem fromJson(final String json, final ObjectMapper objectMapper) {
        // Convert all checked exceptions to Runtime
        try {
            return objectMapper.readValue(json, ConfigurationItem.class);
        } catch (final JsonMappingException | JsonParseException e) {
            throw new ApiException(e.getMessage(), e);
        } catch (final IOException e) {
            throw new ApiConnectionException(e.getMessage(), e);
        }
    }

    /**
    * Converts a JSON InputStream into a ConfigurationItem object using the provided
    * ObjectMapper.
    *
    * @param json Raw JSON InputStream
    * @param objectMapper Jackson ObjectMapper
    * @return ConfigurationItem object represented by the provided JSON
    */
    public static ConfigurationItem fromJson(final InputStream json, final ObjectMapper objectMapper) {
        // Convert all checked exceptions to Runtime
        try {
            return objectMapper.readValue(json, ConfigurationItem.class);
        } catch (final JsonMappingException | JsonParseException e) {
            throw new ApiException(e.getMessage(), e);
        } catch (final IOException e) {
            throw new ApiConnectionException(e.getMessage(), e);
        }
    }

    private final String appletId;
    private final String apiVersion;
    private final String configurationId;
    private final String serviceName;
    private final Integer codeLength;
    private final Boolean allowCustomCode;
    private final Boolean usedForDigitalPayment;
    private final Integer defaultExpiryTime;
    private final Integer defaultMaxTrials;
    private final Integer defaultMaxControls;
    private final String smtpSettingId;
    private final String emailTemplateId;
    private final String smsTemplateId;
    private final ZonedDateTime dateCreated;
    private final ZonedDateTime dateUpdated;

    @JsonCreator
    private ConfigurationItem(
        @JsonProperty("appletId")
        final String appletId,

        @JsonProperty("apiVersion")
        final String apiVersion,

        @JsonProperty("configurationId")
        final String configurationId,

        @JsonProperty("serviceName")
        final String serviceName,

        @JsonProperty("codeLength")
        final Integer codeLength,

        @JsonProperty("allowCustomCode")
        final Boolean allowCustomCode,

        @JsonProperty("usedForDigitalPayment")
        final Boolean usedForDigitalPayment,

        @JsonProperty("defaultExpiryTime")
        final Integer defaultExpiryTime,

        @JsonProperty("defaultMaxTrials")
        final Integer defaultMaxTrials,

        @JsonProperty("defaultMaxControls")
        final Integer defaultMaxControls,

        @JsonProperty("smtpSettingId")
        final String smtpSettingId,

        @JsonProperty("emailTemplateId")
        final String emailTemplateId,

        @JsonProperty("smsTemplateId")
        final String smsTemplateId,

        @JsonProperty("dateCreated")
        final String dateCreated,

        @JsonProperty("dateUpdated")
        final String dateUpdated
    ) {
        this.appletId = appletId;
        this.apiVersion = apiVersion;
        this.configurationId = configurationId;
        this.serviceName = serviceName;
        this.codeLength = codeLength;
        this.allowCustomCode = allowCustomCode;
        this.usedForDigitalPayment = usedForDigitalPayment;
        this.defaultExpiryTime = defaultExpiryTime;
        this.defaultMaxTrials = defaultMaxTrials;
        this.defaultMaxControls = defaultMaxControls;
        this.smtpSettingId = smtpSettingId;
        this.emailTemplateId = emailTemplateId;
        this.smsTemplateId = smsTemplateId;
        this.dateCreated = DateConverter.iso8601DateTimeFromString(dateCreated);
        this.dateUpdated = DateConverter.iso8601DateTimeFromString(dateUpdated);
    }

        public final String getAppletId() {
            return this.appletId;
        }
        public final String getApiVersion() {
            return this.apiVersion;
        }
        public final String getConfigurationId() {
            return this.configurationId;
        }
        public final String getServiceName() {
            return this.serviceName;
        }
        public final Integer getCodeLength() {
            return this.codeLength;
        }
        public final Boolean getAllowCustomCode() {
            return this.allowCustomCode;
        }
        public final Boolean getUsedForDigitalPayment() {
            return this.usedForDigitalPayment;
        }
        public final Integer getDefaultExpiryTime() {
            return this.defaultExpiryTime;
        }
        public final Integer getDefaultMaxTrials() {
            return this.defaultMaxTrials;
        }
        public final Integer getDefaultMaxControls() {
            return this.defaultMaxControls;
        }
        public final String getSmtpSettingId() {
            return this.smtpSettingId;
        }
        public final String getEmailTemplateId() {
            return this.emailTemplateId;
        }
        public final String getSmsTemplateId() {
            return this.smsTemplateId;
        }
        public final ZonedDateTime getDateCreated() {
            return this.dateCreated;
        }
        public final ZonedDateTime getDateUpdated() {
            return this.dateUpdated;
        }

    @Override
    public boolean equals(final Object o) {
        if (this==o) {
            return true;
        }

        if (o == null || getClass() != o.getClass()) {
            return false;
        }

        ConfigurationItem other = (ConfigurationItem) o;

        return Objects.equals(appletId, other.appletId) &&  Objects.equals(apiVersion, other.apiVersion) &&  Objects.equals(configurationId, other.configurationId) &&  Objects.equals(serviceName, other.serviceName) &&  Objects.equals(codeLength, other.codeLength) &&  Objects.equals(allowCustomCode, other.allowCustomCode) &&  Objects.equals(usedForDigitalPayment, other.usedForDigitalPayment) &&  Objects.equals(defaultExpiryTime, other.defaultExpiryTime) &&  Objects.equals(defaultMaxTrials, other.defaultMaxTrials) &&  Objects.equals(defaultMaxControls, other.defaultMaxControls) &&  Objects.equals(smtpSettingId, other.smtpSettingId) &&  Objects.equals(emailTemplateId, other.emailTemplateId) &&  Objects.equals(smsTemplateId, other.smsTemplateId) &&  Objects.equals(dateCreated, other.dateCreated) &&  Objects.equals(dateUpdated, other.dateUpdated)  ;
    }

    @Override
    public int hashCode() {
        return Objects.hash(appletId, apiVersion, configurationId, serviceName, codeLength, allowCustomCode, usedForDigitalPayment, defaultExpiryTime, defaultMaxTrials, defaultMaxControls, smtpSettingId, emailTemplateId, smsTemplateId, dateCreated, dateUpdated);
    }

}

