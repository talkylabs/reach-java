/*
 * This code was generated by
 *  ___ ___   _   ___ _  _    _____ _   _    _  ___   ___      _   ___ ___      ___   _   ___     ___ ___ _  _ ___ ___    _ _____ ___  ___ 
 * | _ \ __| /_\ / __| || |__|_   _/_\ | |  | |/ | \ / / |    /_\ | _ ) __|___ / _ \ /_\ |_ _|__ / __| __| \| | __| _ \  /_\_   _/ _ \| _ \
 * |   / _| / _ \ (__| __ |___|| |/ _ \| |__| ' < \ V /| |__ / _ \| _ \__ \___| (_) / _ \ | |___| (_ | _|| .` | _||   / / _ \| || (_) |   /
 * |_|_\___/_/ \_\___|_||_|    |_/_/ \_\____|_|\_\ |_| |____/_/ \_\___/___/    \___/_/ \_\___|   \___|___|_|\_|___|_|_\/_/ \_\_| \___/|_|_\
 * 
 * Reach Messaging API
 * Reach SMS API helps you add robust messaging capabilities to your applications.  Using this REST API, you can * send SMS messages * track the delivery of sent messages * schedule SMS messages to send at a later time * retrieve and modify message history
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.talkylabs.reach.rest.api.messaging;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.JsonParseException;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.talkylabs.reach.base.Resource;
import com.talkylabs.reach.converter.DateConverter;
import com.talkylabs.reach.converter.Promoter;
import com.talkylabs.reach.exception.ApiConnectionException;

import com.talkylabs.reach.exception.ApiException;

import lombok.ToString;

import java.io.IOException;
import java.io.InputStream;
import java.time.ZonedDateTime;

import java.util.Objects;


import java.math.BigDecimal;

@JsonIgnoreProperties(ignoreUnknown = true)
@ToString
public class MessagingItem extends Resource {
    private static final long serialVersionUID = 83871601684946L;

    public static MessagingItemDeleter deleter(final String messageId){
        return new MessagingItemDeleter(messageId);
    }

    public static MessagingItemFetcher fetcher(final String messageId){
        return new MessagingItemFetcher(messageId);
    }

    public static MessagingItemReader reader(){
        return new MessagingItemReader();
    }

    public static MessagingItemSender sender(final String dest, final String src, final String body){
        return new MessagingItemSender(dest, src, body);
    }

    public static MessagingItemUnscheduler unscheduler(final String messageId){
        return new MessagingItemUnscheduler(messageId);
    }

    public static MessagingItemUpdater updater(final String messageId, final String body){
        return new MessagingItemUpdater(messageId, body);
    }

    /**
    * Converts a JSON String into a MessagingItem object using the provided ObjectMapper.
    *
    * @param json Raw JSON String
    * @param objectMapper Jackson ObjectMapper
    * @return MessagingItem object represented by the provided JSON
    */
    public static MessagingItem fromJson(final String json, final ObjectMapper objectMapper) {
        // Convert all checked exceptions to Runtime
        try {
            return objectMapper.readValue(json, MessagingItem.class);
        } catch (final JsonMappingException | JsonParseException e) {
            throw new ApiException(e.getMessage(), e);
        } catch (final IOException e) {
            throw new ApiConnectionException(e.getMessage(), e);
        }
    }

    /**
    * Converts a JSON InputStream into a MessagingItem object using the provided
    * ObjectMapper.
    *
    * @param json Raw JSON InputStream
    * @param objectMapper Jackson ObjectMapper
    * @return MessagingItem object represented by the provided JSON
    */
    public static MessagingItem fromJson(final InputStream json, final ObjectMapper objectMapper) {
        // Convert all checked exceptions to Runtime
        try {
            return objectMapper.readValue(json, MessagingItem.class);
        } catch (final JsonMappingException | JsonParseException e) {
            throw new ApiException(e.getMessage(), e);
        } catch (final IOException e) {
            throw new ApiConnectionException(e.getMessage(), e);
        }
    }
    public enum MessageType {
        OUTBOUND("outbound"),
        INBOUND("inbound");

        private final String value;

        private MessageType(final String value) {
            this.value = value;
        }

        public String toString() {
            return value;
        }

        @JsonCreator
        public static MessageType forValue(final String value) {
            return Promoter.enumFromString(value, MessageType.values());
        }
    }
    public enum Status {
        SENT("sent"),
        SCHEDULED("scheduled"),
        FAILED("failed"),
        DELIVERED("delivered"),
        UNDELIVERED("undelivered"),
        CANCELED("canceled"),
        ACCEPTED("accepted"),
        QUEUED("queued"),
        SENDING("sending"),
        RECEIVED("received"),
        RECEIVING("receiving");

        private final String value;

        private Status(final String value) {
            this.value = value;
        }

        public String toString() {
            return value;
        }

        @JsonCreator
        public static Status forValue(final String value) {
            return Promoter.enumFromString(value, Status.values());
        }
    }

    private final String appletId;
    private final String apiVersion;
    private final String body;
    private final String dest;
    private final String src;
    private final String bulkId;
    private final Integer numSegments;
    private final Integer numMedia;
    private final BigDecimal price;
    private final String priceUnit;
    private final String messageId;
    private final MessagingItem.Status status;
    private final MessagingItem.MessageType messageType;
    private final Integer errorCode;
    private final String errorMessage;
    private final ZonedDateTime dateCreated;
    private final ZonedDateTime dateSent;
    private final ZonedDateTime dateUpdated;

    @JsonCreator
    private MessagingItem(
        @JsonProperty("appletId")
        final String appletId,

        @JsonProperty("apiVersion")
        final String apiVersion,

        @JsonProperty("body")
        final String body,

        @JsonProperty("dest")
        final String dest,

        @JsonProperty("src")
        final String src,

        @JsonProperty("bulkId")
        final String bulkId,

        @JsonProperty("numSegments")
        final Integer numSegments,

        @JsonProperty("numMedia")
        final Integer numMedia,

        @JsonProperty("price")
        final BigDecimal price,

        @JsonProperty("priceUnit")
        final String priceUnit,

        @JsonProperty("messageId")
        final String messageId,

        @JsonProperty("status")
        final MessagingItem.Status status,

        @JsonProperty("messageType")
        final MessagingItem.MessageType messageType,

        @JsonProperty("errorCode")
        final Integer errorCode,

        @JsonProperty("errorMessage")
        final String errorMessage,

        @JsonProperty("dateCreated")
        final String dateCreated,

        @JsonProperty("dateSent")
        final String dateSent,

        @JsonProperty("dateUpdated")
        final String dateUpdated
    ) {
        this.appletId = appletId;
        this.apiVersion = apiVersion;
        this.body = body;
        this.dest = dest;
        this.src = src;
        this.bulkId = bulkId;
        this.numSegments = numSegments;
        this.numMedia = numMedia;
        this.price = price;
        this.priceUnit = priceUnit;
        this.messageId = messageId;
        this.status = status;
        this.messageType = messageType;
        this.errorCode = errorCode;
        this.errorMessage = errorMessage;
        this.dateCreated = DateConverter.iso8601DateTimeFromString(dateCreated);
        this.dateSent = DateConverter.iso8601DateTimeFromString(dateSent);
        this.dateUpdated = DateConverter.iso8601DateTimeFromString(dateUpdated);
    }

        public final String getAppletId() {
            return this.appletId;
        }
        public final String getApiVersion() {
            return this.apiVersion;
        }
        public final String getBody() {
            return this.body;
        }
        public final String getDest() {
            return this.dest;
        }
        public final String getSrc() {
            return this.src;
        }
        public final String getBulkId() {
            return this.bulkId;
        }
        public final Integer getNumSegments() {
            return this.numSegments;
        }
        public final Integer getNumMedia() {
            return this.numMedia;
        }
        public final BigDecimal getPrice() {
            return this.price;
        }
        public final String getPriceUnit() {
            return this.priceUnit;
        }
        public final String getMessageId() {
            return this.messageId;
        }
        public final MessagingItem.Status getStatus() {
            return this.status;
        }
        public final MessagingItem.MessageType getMessageType() {
            return this.messageType;
        }
        public final Integer getErrorCode() {
            return this.errorCode;
        }
        public final String getErrorMessage() {
            return this.errorMessage;
        }
        public final ZonedDateTime getDateCreated() {
            return this.dateCreated;
        }
        public final ZonedDateTime getDateSent() {
            return this.dateSent;
        }
        public final ZonedDateTime getDateUpdated() {
            return this.dateUpdated;
        }

    @Override
    public boolean equals(final Object o) {
        if (this==o) {
            return true;
        }

        if (o == null || getClass() != o.getClass()) {
            return false;
        }

        MessagingItem other = (MessagingItem) o;

        return Objects.equals(appletId, other.appletId) &&  Objects.equals(apiVersion, other.apiVersion) &&  Objects.equals(body, other.body) &&  Objects.equals(dest, other.dest) &&  Objects.equals(src, other.src) &&  Objects.equals(bulkId, other.bulkId) &&  Objects.equals(numSegments, other.numSegments) &&  Objects.equals(numMedia, other.numMedia) &&  Objects.equals(price, other.price) &&  Objects.equals(priceUnit, other.priceUnit) &&  Objects.equals(messageId, other.messageId) &&  Objects.equals(status, other.status) &&  Objects.equals(messageType, other.messageType) &&  Objects.equals(errorCode, other.errorCode) &&  Objects.equals(errorMessage, other.errorMessage) &&  Objects.equals(dateCreated, other.dateCreated) &&  Objects.equals(dateSent, other.dateSent) &&  Objects.equals(dateUpdated, other.dateUpdated)  ;
    }

    @Override
    public int hashCode() {
        return Objects.hash(appletId, apiVersion, body, dest, src, bulkId, numSegments, numMedia, price, priceUnit, messageId, status, messageType, errorCode, errorMessage, dateCreated, dateSent, dateUpdated);
    }

}

